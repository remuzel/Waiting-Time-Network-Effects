import argparse
import logging
import numpy as np
from tqdm import tqdm

np.random.seed(1_218_042)

from simulator import AgentSimulator

# Import some modules from the base simulator
import sys
sys.path.append("..")
from base_simulation.environment import City
from base_simulation.utils import plot_market_share, conf_interval, plot_heatmaps


if __name__ == "__main__":

    LOGGER = logging.getLogger(__name__)

    arguments = {
        '--N': ["Population size to consider during the simulation.", int, 1_000],
        '--P': ["Number of platforms to consider during the simulation.", int, 2],
        '--t': ["Duration of the simulation.", int, 1_000],
        '--it': ["Number of iterations to get average.", int, 1_000],
        '--plt': ["Filename underwich to save the figure.", str, None],
        '--city': ["Flag to show the city as a grid of densities.", bool, False],
        '--f': ["Attenuating factor to be used in size vs distance equation.", str, "lorenz"],
        '--c': ["Alpha factor for the lorenz scaling", float, 2],
        '--r': ["Proportion of rider agents generated by the simulation.", float, 0.95],
        '--mu_r': ["Rate at which riders leave the platform.", float, 0.5],
        '--mu_d': ["Rate at which drivers leave the platform.", float, 0.5],
        '--raw': ["Flag to save the raw heatmap data.", bool, False],
        '--plt_type': ["1) Plot marketshares only 2) Plot population only 3) Plot both", int, 3],
        '--n_joins': ["Number of agents that are released to the market at each iteration.", int, 1],
        '--eta': ["The price coefficient eta", float, 0]
    }

    parser = argparse.ArgumentParser()
    for arg, (_help, _type, _default) in arguments.items():
        parser.add_argument(arg, help=_help, type=_type, default=_default)
    parser.add_argument('--delay', help="List of times at which corresponding platforms should be introduced.", nargs='+', type=int, default=None)
    args = parser.parse_args()

    if args.delay is not None:
        if len(args.delay) != args.P:
            raise ValueError(f'--delay must have as many elements as value of --P. Found --delay {len(args.delay)} and --P {args.P}')
        if 0 not in args.delay:
            raise ValueError(f'--delay must contain a platform starting at time 0. Found --delay {args.delay}')

    names = ['Uber', 'Black Cab', 'Bolt', 'Kapten', 'Heetch'][:args.P]
    
    iter_ms = []
    iter_r = []
    iter_d = []
    city = City()
    # Run the simulation it times
    for i in tqdm(range(args.it)):
        sim = AgentSimulator(args.N, names, city_shape=city.density.shape,
                            rider_proportion=args.r, lorenz=args.c,
                            mu_D=args.mu_d, mu_R=args.mu_r, eta=args.eta,
                            n_joins=args.n_joins, delays=args.delay)
        # Sort the returned shares and agent numbers (who the winner is doesn't matter)
        m_shares = sorted(sim.run().get_market_shares(), key=lambda x: x[-1])
        riders = sorted(sim.get_riders(), key=lambda x: x[-1])
        drivers = sorted(sim.get_drivers(), key=lambda x: x[-1])
        # Store the data
        iter_ms.append(m_shares)
        iter_r.append(riders)
        iter_d.append(drivers)
    # Get means of winner / looser over the runs
    _format = lambda d, i: np.array([conf_interval(np.array(p), axis=0)[i] for p in zip(*d)])
    avg_ms, avg_r, avg_d = _format(iter_ms, 0), _format(iter_r, 0), _format(iter_d, 0)
    std_ms, std_r, std_d = _format(iter_ms, 1), _format(iter_r, 1), _format(iter_d, 1)
    data = {
        "avg_ms": avg_ms,
        "std_ms": std_ms,
        "avg_r": avg_r,
        "std_r": std_r,
        "avg_d": avg_d,
        "std_d": std_d
    }
        
    # Plot the results
    plot_market_share(data, "agent", N=args.N*args.n_joins, r=args.r, filename=args.plt, _type=args.plt_type)